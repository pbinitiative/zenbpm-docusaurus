syntax = "proto3";
package grpc;

option go_package = "github.com/pbinitiative/zenbpm/internal/grpc/proto";

message ActivateJobsRequest {
	// Job type, matching the task definition in the BPMN process
	string type = 1;
	// Name of the worker activating the jobs, used mostly for logging
	string worker = 2;
	// Jobs returned after this call will not be activated by another call until the
	// timeout has been reached. Time out is in milliseconds.
	int64 timeout = 3;
	// Maximum jobs to activate
	int32 maxJobsToActivate = 4;
	// List of specific variables to retrieve with the job. If empty, all variables
	// visible at the time of activation in the job's scope will be included
	repeated string fetchVariable = 5;
	// Request will be completed when at least one job is activated or request timeouts:
	// - 0: Use default timeout
	// - positive: Wait up to specified milliseconds
	// - negative: Return immediately without waiting
	int64 requestTimeout = 6;
	// List of tenant IDs to activate jobs for
	repeated string tenantIds = 7;
	// Correlation ID, application specific
	string correlationId = 8;
}

message ActivateJobsResponse {
	repeated ActivatedJob jobs = 1;
}

message ActivatedJob {
	// Unique job identifier
	int64 key = 1;
	// Task type (should match activation request)
	string type = 2;
	// Instance key of job's process
	int64 processInstanceKey = 3;
	// BPMN process ID of job's process
	string bpmnProcessId = 4;
	// Process definition version number
	int32 processDefinitionVersion = 5;
	// Key of the job process definition
	int64 processDefinitionKey = 6;
	// Element ID of associated task
	string elementId = 7;
	// Key identifying the associated task, unique within the scope of the
	// process instance
	int64 elementInstanceKey = 8;
	// Custom headers defined during modelling. JSON document.
	string customHeaders = 9;
	// Name of the worker which activated this job
	string worker = 10;
	// Retries left for this job. Should always be positive.
	int32 retries = 11;
	// When the job can be activated again, as a UNIX epoch timestamp
	int64 deadline = 12;
	// All variables visible in the task scope. JSON document.
	string variables = 13;
	// ID of the tenant that owns the job
	string tenantId = 14;
}

message CompleteJobRequest {
	// Job identifier, from ActivateJobsResponse
	int64 jobKey = 1;
	// All variables visible in current task scope. JSON document.
	string variables = 2;
	// Result of the completed job, determined by the worker.
	optional JobResult result = 3;
	// correlation ID, application specific
	string correlationId = 4;
}

message JobResult{
	// Indicates task rejection status.
	// When true, rejects completion and keeps task active
	// Defaults to false.
	optional bool denied = 1;
	// Updated task attributes:
	// - `assignee` (clear with empty string)
	// - `dueDate` (clear with empty string)
	// - `followUpDate` (clear with empty string)
	// - `candidateGroups` (clear with empty list)
	// - `candidateUsers` (clear with empty list)
	// - `priority` (0-100, defaults to 50)
	// Omitted attributes remains unchanged
	optional JobResultCorrections corrections = 2;
	// Reason of task denial
	optional string deniedReason = 3;
}

message JobResultCorrections {
	// Task assignee
	optional string assignee = 1;
	// Task due date
	optional string dueDate = 2;
	// Task follow-up date
	optional string followUpDate = 3;
	// Task eligible users
	optional StringList candidateUsers = 4;
	// Task eligible groups
	optional StringList candidateGroups = 5;
	// Task priority
	optional int32 priority = 6;
}

message StringList {
	repeated string values = 1;
}

message CompleteJobResponse {
}

message FailJobRequest {
	// Job identifier, from ActivateJobsResponse
	int64 jobKey = 1;
	// Retries the job should have left.
	int32 retries = 2;
	// Message with description why the job failed
	string errorMessage = 3;
	// Backoff timeout for the next retry. In milliseconds.
	int64 retryBackOff = 4;
	// All variables visible in current task scope. JSON document.
	string variables = 5;
	// correlation ID, application specific
	string correlationId = 6;
}

message FailJobResponse {
}

service ZenBpm {
	/*
	   Activate requested maximum of jobs

	   Errors:
		   INVALID_ARGUMENT:
			   - type is blank (empty string, null)
			   - worker is blank (empty string, null)
			   - timeout less than 1
			   - maxJobsToActivate is less than 1
	 */
	rpc ActivateJobs (ActivateJobsRequest) returns (stream ActivateJobsResponse) {
	}

	/*
	   Completes a job with the given variables, which allows completing the associated service task.

	   Errors:
		   NOT_FOUND:
			   - no job exists with the given job key. Note that since jobs are removed once completed,
			   it could be that this job did exist at some point.

		   FAILED_PRECONDITION:
			   - the job was marked as failed. In that case, the related incident must be resolved before
			   the job can be activated again and completed.
	 */
	rpc CompleteJob (CompleteJobRequest) returns (CompleteJobResponse) {
	}

	/*
	   Marks the job as failed; if the retries argument is positive, then the job will be immediately
	   activatable again, and a worker could try again to process it. If it is zero or negative however,
	   an incident will be raised, tagged with the given errorMessage, and the job will not be
	   activatable until the incident is resolved.

	   Errors:
		   NOT_FOUND:
			   - no job was found with the given key

		   FAILED_PRECONDITION:
			   - the job was not activated
			   - the job is already in a failed state, i.e. ran out of retries
	 */
	rpc FailJob (FailJobRequest) returns (FailJobResponse) {
	}
}

// Zeebe compatibility service
service Gateway {
	rpc ActivateJobs (ActivateJobsRequest) returns (stream ActivateJobsResponse) {
	}

	rpc CompleteJob (CompleteJobRequest) returns (CompleteJobResponse) {
	}

	rpc FailJob (FailJobRequest) returns (FailJobResponse) {
	}
}

