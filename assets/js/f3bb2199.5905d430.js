"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8911],{20902:(e,n,s)=>{s.d(n,{A:()=>t});const t="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwIiBoZWlnaHQ9IjEyMCIgdmlld0JveD0iMCAwIDEyMCAxMjAiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiAgPCEtLSBPdXRlciBjaXJjbGUgLS0+CiAgPGNpcmNsZSBjeD0iNjAiIGN5PSI2MCIgcj0iNDUiIGZpbGw9IndoaXRlIiBzdHJva2U9ImJsYWNrIiBzdHJva2Utd2lkdGg9IjIiPjwvY2lyY2xlPgoKICA8IS0tIElubmVyIGNpcmNsZSAtLT4KICA8Y2lyY2xlIGN4PSI2MCIgY3k9IjYwIiByPSIzOCIgZmlsbD0id2hpdGUiIHN0cm9rZT0iYmxhY2siIHN0cm9rZS13aWR0aD0iMiI+PC9jaXJjbGU+CgogIDwhLS0gRW52ZWxvcGUgKG9wZW4pIC0tPgogIDxyZWN0IHg9IjM4IiB5PSI1MCIgd2lkdGg9IjQ0IiBoZWlnaHQ9IjI2IiBmaWxsPSJ3aGl0ZSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIj48L3JlY3Q+CgogIDwhLS0gRW52ZWxvcGUgZmxhcCAtLT4KICA8cG9seWxpbmUgcG9pbnRzPSIzOCw1MCA2MCw2NiA4Miw1MCIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJibGFjayIgc3Ryb2tlLXdpZHRoPSIyIj48L3BvbHlsaW5lPgo8L3N2Zz4K"},28453:(e,n,s)=>{s.d(n,{R:()=>a,x:()=>o});var t=s(96540);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}},56116:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>t,toc:()=>d});const t=JSON.parse('{"id":"reference/bpmn/supported-elements/message-catch-event","title":"Message Catch Event","description":"A Message Catch Event is used to model the recipient of a message from an external participant or process.","source":"@site/docs/reference/bpmn/supported-elements/message-catch-event.md","sourceDirName":"reference/bpmn/supported-elements","slug":"/reference/bpmn/supported-elements/message-catch-event","permalink":"/reference/bpmn/supported-elements/message-catch-event","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":100,"frontMatter":{"sidebar_position":100},"sidebar":"docs","previous":{"title":"Event-Based Gateway","permalink":"/reference/bpmn/supported-elements/event-based-gateway"},"next":{"title":"Link Intermediate Throw Event","permalink":"/reference/bpmn/supported-elements/link-intermediate-throw-event"}}');var i=s(74848),r=s(28453);const a={sidebar_position:100},o="Message Catch Event",c={},d=[{value:"Key characteristics",id:"key-characteristics",level:2},{value:"Message subscription",id:"message-subscription",level:4},{value:"Message subscription pointer",id:"message-subscription-pointer",level:4},{value:"Supported message catch event types",id:"supported-message-catch-event-types",level:2},{value:"Graphic Notation",id:"graphic-notation",level:2},{value:"Usage",id:"usage",level:2}];function l(e){const n={a:"a",br:"br",h1:"h1",h2:"h2",h4:"h4",header:"header",img:"img",li:"li",mermaid:"mermaid",p:"p",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"message-catch-event",children:"Message Catch Event"})}),"\n",(0,i.jsx)(n.p,{children:"A Message Catch Event is used to model the recipient of a message from an external participant or process."}),"\n",(0,i.jsx)(n.h2,{id:"key-characteristics",children:"Key characteristics"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Catching behavior:"}),(0,i.jsx)(n.br,{}),"\n","A Message Catch Event waits for an incoming message that matches its message definition."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Pauses process execution:"}),(0,i.jsx)(n.br,{}),"\n","When reached, the process execution is suspended until the message is received."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Incoming and outgoing sequence flows:"}),(0,i.jsx)(n.br,{}),"\n","A Message Catch Event must have at least one incoming sequence flow and typically has one outgoing sequence flow."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Message correlation:"}),(0,i.jsx)(n.br,{}),"\n","The received message is correlated to the correct process instance based on the message definition and correlation data."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Subscription lifecycle:"}),(0,i.jsx)(n.br,{}),"\n","At runtime, the engine creates a message subscription when the token reaches the Message Catch Event. The subscription is removed after the message is received and the process continues."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["It indicates that the execution flow will pause until the specified message is received.\n",(0,i.jsx)(n.strong,{children:"ZenBPM implementation"})," of the engine tries to provide guarantees that only one message is active in the system with the same name and correlation key."]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Uniqueness"}),"\nMessage Catch Event is identified by a ",(0,i.jsx)(n.strong,{children:"Correlation Key"})," and ",(0,i.jsx)(n.strong,{children:"Correlation Name"}),".\nCombination of the two parameters is unique for each message catch event.\nRunning into Message Catch Event with an already existing combination results in Incident(link)."]}),"\n",(0,i.jsx)(n.h4,{id:"message-subscription",children:"Message subscription"}),"\n",(0,i.jsx)(n.p,{children:"Message subscription is what we refer to when the engine stores data about the Message Catch Event."}),"\n",(0,i.jsx)(n.h4,{id:"message-subscription-pointer",children:"Message subscription pointer"}),"\n",(0,i.jsxs)(n.p,{children:["Message subscription pointers are used to correlate messages in Zen's architecture of a ",(0,i.jsx)(n.a,{href:"/reference/cluster",children:"distributed system"}),".\nPointers are used to efficiently determine location of a stored subscription, without requiring any internal identifiers.\nPointer's storage partition is calculated from user defined ",(0,i.jsx)(n.strong,{children:"Correlation Key"}),".\nFrom which we can determine partition assigned to ",(0,i.jsx)(n.strong,{children:"Message Subscription"})," and its ",(0,i.jsx)(n.strong,{children:"Process Instance"})," to then correlate the message."]}),"\n",(0,i.jsx)(n.mermaid,{value:'---\nconfig:\n  layout: elk\n---\nflowchart LR\n subgraph s2["Node 2 (partition 1 follower)"]\n        n1["Node<br>step 2: get partition id of the message pointer from correlation key<br>step 4: find leader for message that message pointer points to"]\n  end\n subgraph s3["Node 1 (partition 1 leader)"]\n        n2["Node<br>"]\n        n5["BPMN engine"]\n  end\n subgraph s4["Node 3 (partition 2 leader)"]\n        n3["Node<br> stores message pointer based on correlation key hash"]\n  end\n subgraph s1["Correlate message in a 2 partition setup"]\n        n0["public API"]\n        s2\n        s3\n        s4\n  end\n    n0 L_n0_n1_0@-- step:1 Publish message --\x3e n1\n    n1 L_n1_n2_0@-- step:5 publish message internally --\x3e n2\n    n1 L_n1_n3_0@-- step:3 load message pointer --\x3e n3\n    n2 L_n2_n5_0@-- step:6 activate the message<br> in the engine --\x3e n5\n    n5 L_n5_n3_0@-- step:7 update message pointer state --\x3e n3\n     n0:::Previous\n    classDef Hidden stroke-width:1px, stroke-dasharray:none, opacity: 10%\n    classDef Previous stroke-width:1px, stroke-dasharray:none, opacity: 40%\n    L_n1_n2_0@{ animation: fast }\n    L_n1_n3_0@{ animation: fast }\n    L_n0_n1_0@{ animation: fast }\n    L_n2_n5_0@{ animation: fast }\n    L_n5_n3_0@{ animation: fast }'}),"\n",(0,i.jsx)(n.h2,{id:"supported-message-catch-event-types",children:"Supported message catch event types"}),"\n",(0,i.jsx)(n.p,{children:"The following Message Catch Event types are supported:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Intermediate Message Catch Event:"}),(0,i.jsx)(n.br,{}),"\n","Waits for a message during process execution and continues the flow when the message is received."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Message Boundary Event:"}),(0,i.jsx)(n.br,{}),"\n","Catches a message while the attached activity is active and reacts according to interrupting or non-interrupting behavior."]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Message Start Event:"}),(0,i.jsx)(n.br,{}),"\n","Starts a new process instance when a message is received."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"graphic-notation",children:"Graphic Notation"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Message catch event usage example",src:s(20902).A+"",width:"120",height:"120"})}),"\n",(0,i.jsx)(n.p,{children:"A double-lined circle containing a message (envelope) icon."}),"\n",(0,i.jsx)(n.h2,{id:"usage",children:"Usage"}),"\n",(0,i.jsxs)(n.p,{children:["Messages can be published through API or by triggering ",(0,i.jsx)(n.a,{href:"/reference/bpmn/supported-elements/message-throw-event",children:"Intermediate throw event"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Future plans:\nWe plan to implement message start event along with timer start events in the future."})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(l,{...e})}):l(e)}}}]);