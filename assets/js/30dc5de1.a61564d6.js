"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3824],{28453:(e,r,n)=>{n.d(r,{R:()=>c,x:()=>i});var o=n(96540);const t={},s=o.createContext(t);function c(e){const r=o.useContext(s);return o.useMemo((function(){return"function"==typeof e?e(r):{...r,...e}}),[r,e])}function i(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:c(e.components),o.createElement(s.Provider,{value:r},e.children)}},73937:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>a,contentTitle:()=>i,default:()=>p,frontMatter:()=>c,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"reference/development/error-handling","title":"Error handling","description":"In ZenBPM, in addition to idiomatic Go error handling, we need to return correct HTTP status codes from our exposed REST API.","source":"@site/docs/reference/development/error-handling.md","sourceDirName":"reference/development","slug":"/reference/development/error-handling","permalink":"/reference/development/error-handling","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":10,"frontMatter":{"sidebar_position":10},"sidebar":"docs","previous":{"title":"zenctl","permalink":"/reference/zenctl"},"next":{"title":"Explanation","permalink":"/category/explanation"}}');var t=n(74848),s=n(28453);const c={sidebar_position:10},i="Error handling",a={},d=[];function l(e){const r={code:"code",h1:"h1",header:"header",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(r.header,{children:(0,t.jsx)(r.h1,{id:"error-handling",children:"Error handling"})}),"\n",(0,t.jsxs)(r.p,{children:["In ZenBPM, in addition to idiomatic Go error handling, we need to return correct HTTP status codes from our exposed REST API.\nOften, the error handling happens deep in lower layers of the backend, including behind gRPC calls.\nIn REST controllers, we often lack the information to decide whether to return ",(0,t.jsx)(r.code,{children:"NOT_FOUND"})," (404), ",(0,t.jsx)(r.code,{children:"CLUSTER_ERROR"})," (502), or something else.\nTo solve this, we created a simple error composition to encapsulate an error code. It also implements the ",(0,t.jsx)(r.code,{children:"error"})," interface:"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-go",children:"type ZenError struct {\n    Code ZenErrorCode\n    err  error\n}\n\nfunc (zenError *ZenError) Error() string {\n    return zenError.err.Error()\n}\n"})}),"\n",(0,t.jsx)(r.p,{children:"There already exists functions that create certain type of the errors, for example:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-go",children:"func ClusterError(err error) *ZenError {\n\treturn &ZenError{ClusterErrorCode, err}\n}\n\nfunc NotFound(err error) *ZenError {\n\treturn &ZenError{NotFoundCode, err}\n}\n\n// etc\n"})}),"\n",(0,t.jsxs)(r.p,{children:["So if you want to create a new error that would be mapped to some yet unsupported HTTP status code you can just add a new ",(0,t.jsx)(r.code,{children:"ZenErrorCode"}),"\nand a corresponding function that creates that error."]}),"\n",(0,t.jsx)(r.p,{children:"Then in the code you would create such error, for example as:"}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-go",children:'err := zenerr.NotFound(fmt.Errorf("failed to find process instance %d", req.GetProcessInstanceKey()))\nreturn nil, err\n'})}),"\n",(0,t.jsxs)(r.p,{children:["If you need to serialize and send the error via GRPC then you can simply call ",(0,t.jsx)(r.code,{children:"err.ToProtoError()"}),":"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-go",children:'if engine == nil {\n    err := zenerr.ClusterError(fmt.Errorf("engine with partition %d was not found", partitionId))\n\treturn &proto.GetProcessInstanceResponse{\n\t    Error: err.ToProtoError(),\n    }, err\n}\n'})}),"\n",(0,t.jsxs)(r.p,{children:["From the other side where you make the GRPC call you can wrap the GRPC ",(0,t.jsx)(r.code,{children:"Error"})," to ",(0,t.jsx)(r.code,{children:"ZenError"}),":"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-go",children:'if resp != nil && resp.Error != nil {\n    e := fmt.Errorf("failed to get process instance from partition %d", partitionId)\n    return nil, nil, zenerr.ToZenError(resp.Error, e)\n}\n'})}),"\n",(0,t.jsxs)(r.p,{children:["Finally that's how you can decide what REST error response to return based on the particular ",(0,t.jsx)(r.code,{children:"ZenError"}),":"]}),"\n",(0,t.jsx)(r.pre,{children:(0,t.jsx)(r.code,{className:"language-go",children:"instance, activeElementInstances, err := s.node.GetProcessInstance(ctx, request.ProcessInstanceKey)\nif err != nil {\n\tvar zerr *zenerr.ZenError\n\tif errors.As(err, &zerr) {\n        switch zerr.Code {\n        case zenerr.ClusterErrorCode:\n            return public.GetProcessInstance502JSONResponse(zerr.ToApiError()), nil\n        case zenerr.NotFoundCode:\n            return public.GetProcessInstance404JSONResponse(zerr.ToApiError()), nil\n        default:\n            return public.GetProcessInstance500JSONResponse(zerr.ToApiError()), nil\n        }\n    }\n    return public.GetProcessInstance500JSONResponse(zenerr.TechnicalError(err).ToApiError()), nil\n}\n"})})]})}function p(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,t.jsx)(r,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}}}]);